<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../docbook-xml-4.5/docbookx.dtd">

<book>
	<title>The P* Language</title>
	<chapter>
		<title>Introduction</title>
		<section>
			<title>What is P*?</title>
			<para>P* (P-star) is a shortname for "Web P* Language". It is unknown what the "P" actually stands for, so a star is used to indicate that any word starting with a "P" may be used. It does not mean that the name can be any number of P's. Oh, by the way, the word has to relate to computers. If you didn't think about any non-computer P-word, you're in the target audience of this article.
			</para>
			<para>P* is a computer programming language specifically designed to make web progamming easy by incorporating frequent operations into the language. P* uses a C-like syntax, so it whould be easy to begin using if you have ever used C, C#, C++, Java, Perl, PHP and many others. P* is also highly inspired from some of these languages, and tries to implement the best of them while also using completely new methods for solving different programming tasks.
			</para>
			<para>P* is run like a script by it's interpreter which is written in C++. It is currently under development, and if you have any suggestions for new features, shout out now! Also feel free to write new features and send them in.
			</para>
			<para>
			P* free software and is currently licenced with GPLv3 <ulink>http://www.gnu.org/copyleft/gpl.html</ulink>
			</para>
		</section>
		<section>
			<title>We Want Meat!</title>
			<para>This is the official "Hello World!"-example of P*
			<programlisting language="c">
#!/usr/bin/wpl -f
SCENE main {
	echo "Hello World!\n";
}
			</programlisting>
			</para>
			<para>
				This docbook is written by Atle Solbakken <email>atle@goliathdns.no</email>
			</para>
		</section>
		<section>
			<title>Why Another Language?</title>
			<para>You might think that if someone decides to begin on the huge task of designing a new programming language, that someone has probably gone crazy.
			And you're spot on. Years of fierce fighting with different programming languages can drive the most well-composed person mad (this 'someone' we refer to here has never been well-composed, but if he was before he started programming, he would certeinly have lost that property by now).
			</para>
			<para>P* tries to simplify tasks like HTML templates and database handling, where most languages use procedural and error-prone methods. P* introduces completely new methods of making life easier when dealing with this.
			</para>
		</section>
	</chapter>
	<chapter>
		<title>Get P* !</title>
		<para>
		The source of P* is currently available from Github:
		</para>
		<para>
		<ulink>https://github.com/atlesn/P-star</ulink>
		</para>
		<para>
		<code>$Â git clone https://github.com/atlesn/P-star.git</code>
		</para>
		<para>
		</para>
	</chapter>		
	<chapter>
		<title>The Idea behind P*</title>
		<para>All programming languages have advantages and disanvantages. These two creatures are happily married, and they can't be separated. If you try to kill a disadvantage, it's beloved advantage will commit suicide, and you're back where you started. If you overlap a disadvantage with another advantage, a new disadvantage comes along with it.
		</para>
		<para>
		Does this means that we will never have a perfect programming lanuage?
		It probably does.
		However, P* has made an attempt to get around this by selecting which bad things to have first and seeing what advantages we get with those afterwards.
		</para>
		<para>A P* program is run by an interpreter engine, and this is bad for speed.
		We compensate for that by making the language simple, which actually has the side effect of making it suitable for web programming.
		What web programming is about is, yes you guessed correct, "web", and the tools to create the web should be designed with that in mind.
		</para>
		<section>
			<title>Boilerplate Code</title>
			<para>Boilerplate code is equal copies of code that you have to repeat many times in a program to make it work.
			This includes stuff like checking return values from library functions and printing error messages, or to including modules and header files at the top of a program.
			</para>
			<bridgehead>MySQL prepared statements in Java</bridgehead>
			<para>One of the worst time-consuming copy-paste-editing you will ever come over is creating a prepared statement.
			Under follows an example in the Java-language (which is copy-pasted-edited from some page found on Google).
			Notice that the word <code>PreparedStatement</code> is used seven times, and that you have to deal with the member methods <code>setString</code> and <code>setInt</code> of this object for every single variable.
			</para>
			<programlisting language="java">
Class.forName("com.mysql.jdbc.Driver");
connect = DriverManager.getConnection("jdbc:mysql://localhost/animal_kingdom?" + "user=dog&amp;password=i_hate_cats");

// It is extremely boring work to set all this fields
preparedStatement = connect.prepareStatement("INSERT INTO animal_kingdom.persons VALUES (?,?,?,?,?)");
preparedStatement.setString(1, "Jo");
preparedStatement.setString(2, "Lene");
preparedStatement.setString(3, "jolene@hotmail.com");

// Sometimes we need to store strange properties of a person
preparedStatement.setInt(4, 135);
preparedStatement.setInt(5, 4);
preparedStatement.executeUpdate();
			</programlisting>
			<para>You begin to wonder why on earth you have to tell Java that "Jo" is a string type.
			You also have the manual work of counting all the question marks and setting the variables in correct order.
			This work, of course, becomes really fun when you also have to deal with column names in the query and you have 20 columns of different types to insert.
			</para>
			<para>The P* author, also referred to as 'someone' in this article, has once been forced to write a wrapper class just to keep track of column names, values and question marks.
			We don't want to spend time doing this, we want to create web pages! Let's have some more meat.
			</para>
			<bridgehead>MySQL prepared statements in P*</bridgehead>
			<para>Next comes the same example in P*, lets just specify the variables first instead of inlining, like you would normally do:
			<programlisting language="c">

string name = "Jo";
string surename = "Lene";
string email = "jolene@hotmail.com";
int weight = 135;   /* In kilograms */
int width = 4;      /* In feet */

SQL sql {
	INSERT INTO animal_kingdom.persons VALUES (
		{@name}, {@surename}, {@email}, {@weight}, {@width}
	)
}

MYSQL mysql->connect("localhost", "dog", "i_hate_cats");
mysql->select_db("animal_kingdom");

MYSQL_STATEMENT stmt = mysql->new_statement();
stmt->prepare(sql);
stmt->execute();
			</programlisting>
			</para>
			<bridgehead>Common reactions to this example</bridgehead>
			<itemizedlist spacing="normal" mark="bullet"> 
			<listitem>Wait a minute...You said you wouldn't inline the variables, but you did?
			</listitem>
			<listitem>You idiot!!! This is SQL -- IN -- JEC -- TION -- !!!!
			</listitem>
			</itemizedlist>
			<bridgehead>Counter-strike</bridgehead>
			<para>This way of specifying a prepared statement is P* magic.
			We would not normally, and shouln't either, put variables inside the SQL-string.
			However, because we are lazy (and to avoid the horrible and error-prone code you see in the first example), we might be tempted to do just that.
			With P* you can put the variables inside the SQL-string WITHOUT them being concatenated.
			</para>
			<para>The whole SQL-object is a chain of strings and value pointers, and P* does the dirty work of passing each variable to MySQL with the correct type set.
			The variables are replaced with question marks before passed to MySQL, making it look like the Java-example.
			</para>
		</section>
		<section>
			<title>I Know What Types My Variables are!</title>
			<para>One important element of making a program efficient, is to use correct types for your variables.
			When you've programmed for a while, type selection becomes natural, and you don't think much about it.
			</para>
			<para>Some languages try to help the user by using automatic types.
			This is supposed to make it easier to write.
			P* does allow implict converting between primitive types, but no variables can be typeless.
			</para>
			<para>It is not much work, however, to write <code>int</code> or <code>string</code> in front of a variable.
			This also helps make programs more readable, and it makes programs faster.
			</para>
			<para>Variables in P* are stored in memory as their C/C++ equalient type. Size of the type depend on the platform the interpreter is compiled on.
			</para>
			<bridgehead>Types, you say? Let's have 'em!</bridgehead>
			<para>
			Example of P* types and their corresponding C-types:
			<programlisting language="c">
int a = -10;		/* Integer			long int			*/
uint b = 2;		/* Unsigned integer		long unsigned int		*/

llint c = -10;		/* Long long integer		long long int			*/
lluint e = 2;		/* Unsigned long long integer	long long unsigned int		*/

double d = 2.00003;	/* Double precision		double				*/
float f = 2.00003;	/* Floating point		float				*/

string p = "P*";	/* String			uses &lt;string&gt; from c++	*/
			</programlisting>
			</para>
			<para>And here is a small program just in case you're still hungry:
			<programlisting language="c">
int base = 2;
int exp = 1;
int exp_max = 40;
lluint result = 1;

while (exp &lt;= exp_max) {
	result *= base;
	echo "$base exp $exp is $result";
	exp++;
}
			</programlisting>
			</para>
		</section>
		<section>
			<title>What template engine should I choose?</title>
			<para>With P*, you don't need any template engine. Templates are in-language!</para>
			<para>Here is an example of a simple web application constisting of the files <code>test_tmpl.pstar</code> and <code>test.pstar</code>, which you can run with CGI on your favorite web/database-server:</para>
			<para>
			P* supports common AJAX-operations like replacing text inside a &lt;div&gt;. If you want to output a variable interpolated into the template, the id-tag of the previous element in you HTML is used as variable name when the JSON is generated. In the example below, a jQuery scripts does this job. 
			</para>
			<para>
			<programlisting language="c">
/* test_tmpl.pstar */
HTML_TEMPLATE test_template {
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt;
	&lt;/script&gt;
	&lt;script&gt;
	//  P* also supports application/x-www-form-urlencoded and the GET-method
	$(document).ready(function() {
		$("#my_form").on("submit", function(event) {
			event.preventDefault();

			var form_data = new FormData(this);
			$.ajax({
				url:            '?',
				type:           'POST',
				data:           form_data,
				mimeType:       "multipart/form-data",
				dataType:       'json',
				contentType:    false,
				cache:          false,
				processData:    false,
				success:        function(data, status, jqXHR) {
				$.each(data, function(key, val) {
					if (key!="") {
					$("#text_div").html(val);
					}
					});
				},
				error:          function(jqXHR, status, error_thrown) {

				}
			});
		});
	});
	&lt;/script&gt;
	&lt;style type="text/css"&gt;
	body {
		background-color: #eee;
	}
	form * {
		margin: 5px;
	}
	select {
		width: 100%;
	}
	option {
		overflow: hidden;
		margin: 0px;
	}
	#form_div {
		padding: 30px;
		width: 40%;
		margin: 0 auto;
		background: #aa0;
		text-align: center;
		border-radius: 10px;
	}
	#form_div span {
		font-weight: bold;
	}
	#result_parent {
		padding: 30px;
		width: 40%;
		margin: 0 auto;
		text-align: center;
		background-color: #fff;
		border-radius: 10px;
		margin-top: 10px;
	}
	#result_parent span {
		font-weight: bold;
	}
	#result_parent div {
		background-color: #ddd;
		border: 1px solid #000;
		margin-top: 30px;
		border-radius: 10px;
	}
	&lt;/style&gt;
	&lt;title&gt;My page&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;form id="my_form" method="POST" encoding="multipart/form-data"&gt;
	&lt;div id="form_div"&gt;
	&lt;span&gt;Please choose a string to retrieve from the database:&lt;/span&gt;
		&lt;select name="id" id="id_select"&gt;

	&lt;!-- This a P* template while-loop --&gt;

	{@LOOP (row++)
		&lt;option value="{@row["id"]}"&gt;{@row["text"]}&lt;/option&gt;
	}

	&lt;/select&gt;
	&lt;input type="submit"&gt;
	&lt;/div&gt;
	&lt;/form&gt;
	&lt;div id="result_parent"&gt;
	&lt;span&gt;The string is retrived with AJAX and printed out here:&lt;/span&gt;

	&lt;!-- This is P* variable interpolation --&gt;

	&lt;div id="{@"text_div"}"&gt;-{@text}&lt;/div&gt;

	&lt;/div&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

/* test.pstar */
#!/usr/test/bin/wpl -f

#INCLUDE test_tmpl.pstar;

SCENE main {
	/* POST-data only, not GET */
	POST post;

	int id;
	/*
	   All variables from POST and GET are constructed as arrays,
	   independent of how many variables with equal names we have.
	   The star selects the first element.
	   */
	if (*post["id"]) {
		id = *post["id"];
	}

	MYSQL mysql;
	mysql->connect("127.0.0.1", "my_user_name", "my_password);
	mysql->select_db("my_database");
	MYSQL_STMT stmt = mysql->new_statement();

	/*
	   We need a table with one numeric id-column and one text-column. Put nice data in it
	*/
	SQL sql_all {
		SELECT * FROM variables GROUP BY(id)
	}
	SQL sql_single {
		SELECT * FROM variables WHERE id={@id}
	}

	/*
	   If the POST-variable 'id' is set, we limit the query
	   */
	if (id) {
		if (!stmt->prepare(sql_single)) {
			errcho "Could prepare query: " . mysql->error() . "\n";
		}
	}
	else {
		if (!stmt->prepare(sql_all)) {
			errcho "Could prepare query: " . mysql->error() . "\n";
		}
	}

	if (!stmt->execute()) {
		errcho "Could not execute query: " . mysql->error() . "\n";
	}

	MYSQL_ROW row = stmt->get_row_iterator();

	/*
	   If the POST-variable 'id' is set, we output JSON to the client!
	   */
	if (id) {
		string text = "(Not found)";
		if (row++) {
			text = row["text"];
		}
		#JSON_BEGIN;
		#HTML_TEMPLATE_VAR test_template text;
		#JSON_END;
	}
	else {
		#CONTENT_TYPE text/html;
		#HTML_TEMPLATE test_template;
	}
}
			</programlisting>
			</para>
		</section>
	</chapter>
	<chapter>
		<title>P* project</title>
		<emphasis>Read this if you're into free software development!</emphasis>
		<section>
			<title>Project status</title>
			<para>
			The P*-project currently constist of only one person. For the language to be taken to the next level, help is needed!
			</para>
			<table>
				<title>List of project tasks</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Task</entry>
						<entry>Status</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Spread the word</entry>
						<entry>Currently in progress, but help needed.</entry>
					</row>
					<row>
						<entry>Documentation</entry>
						<entry>This document is the only documentation apart from the source code. Need more!</entry>
					</row>
					<row>
						<entry>Web-page / bug-tracking</entry>
						<entry>Help needed</entry>
					</row>
					<row>
						<entry>Testing</entry>
						<entry>Help is needed with writing production web pages in P* to find out what needs to be done</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</section>
	</chapter>
	<chapter>
		<title>Development</title>
		<emphasis>Read this if you like to write stuff!</emphasis>
		<section>
			<title>Status Quo</title>
			<para>The base of the P* interpreter is written in C++ and runs quite well.
			The development is still in an early phase, and there has been many rewrites of particularry the expression handling and value subsystem.
			A rewrite takes two days of writing and one or to days fixing compiling errors, so it gives a good feeling that this hasn't been needed for quite a while.
			</para>
			<para>
			The implementation of loadable modules, with MySQL as the first one out, can be done without any change to the base.
			This might indicate that things now are implemented in a reasonable way.
			</para>
		</section>
		<section>
			<title>How it's run</title>
			<para>
			A session is divided into parsing and running. P* parses the input file and creates a hierarchy of all objects which exis in the code. Variables, functions and types are registered into <code>namespace</code>s of each block.
			</para>
			<para>
			At run time, every object holds <code>state</code> objects for their children.
			These nests, and the first state is held outside the program structure.
			The states are created on the first run of each element.
			</para>
			<para>
			If you call a function from two different locations, the function gets one state for each place it is called from.
			If you nest function calls, one state is created for each nested call.
			If you call the nested function again the same way, it re-uses the states from the last call.
			This saves memory allocations.
			</para>
			<para>
			Some objects are also <code>namespace sessions</code>, like blocks. These hold variables during run-time.
			The variables are copied from the original namespace (created on parse-time) the first time the block is called from a specific location.
			This method allows the same program to run threaded on the same object structure, as no objects created on parsing are in any way changed when the program runs. When run as a web server module, this methos is ideal as most of the work with initializing a program is only done the first time.
			</para>
			<para>
			It should also be easy to implement threading in P*.
			</para>
		</section>
		<section>
			<title>Speed</title>
			<para>Of course, since many things in P* happen behind the scenes, it runs slower than if you had written the same program in C and compiled it.
			P*, however, strives to keep this overhead to a minimum.
			It must also be said that the author of P* is extremely lazy, and the codebase is therefore quite small and efficient.
			</para>
			<para>
			A test run of a PHP "Hello World!"-program run 100 times took 1.5 seconds. On the same box, P* did it in 0.4 seconds. This however only tells us that P* parses the source and initializes faster than PHP. PHP does other things faster, like running of expressions.
			</para>
			<para>
			A small program in P* does ~300 memory allocations, while PHP does 18 000.
			There is no current measurement of performance when P* is run as module in a web serverm, because no such module currently exists (but there will be one soon !).
			</para>
			<para>
			The expression running in P* is not omptimized very much yet, but on my home computer, it can run a short expression in a loop (like <code>i++</code>) 50 million times in about 3 seconds. This should be fast enough for now.
			</para>
		</section>
		<section>
			<title>Database handling</title>
			<para>
			The P* interpreter has custom C++ wrapper classes for the official MySQL C client API.
			The good mix of C and C++ coding techniques makes the code taste very good.
			</para>
			<para>
			P* wraps destructor functions of MySQL, like <code>mysql_stmt_close()</code> into destructors of it's own classes and forgets about them.
			</para>
		</section>
		<section>
			<title>Important functionality to-be-written</title>
			<para>
			Help with development is needed! Please consider joining in or submitting code. <email>atle@goliathdns.no</email>
			</para>
			<para>
			<table>
				<title>List of future functionality</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Function</entry>
						<entry>Status</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Perl-like in-language regular expressions</entry>
						<entry>Not written</entry>
					</row>
					<row>
						<entry>File I/O</entry>
						<entry>Not written (supports STDIN)</entry>
					</row>
					<row>
						<entry>HTTP Cookies</entry>
						<entry>Not written</entry>
					</row>
					<row>
						<entry>Character sets</entry>
						<entry>P* is currently only safe with UTF-8</entry>
					</row>
					<row>
						<entry>Database</entry>
						<entry>P* currently only supports simple MySQL prepared statements, run unbuffered</entry>
					</row>
					<row>
						<entry>Apache module</entry>
						<entry>Not written</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			</para>
		</section>
	</chapter>
</book>
